# Glassroot – Functional Requirements

## 1. Overview
- Purpose: Provide document storage with semantic search over document content.
- Scope: Backend API for document CRUD/read-only listing and vector search; client configuration for LLM-related settings; deployment and storage on Cloudflare.
- Users: Any client consuming the HTTP API (web/mobile/desktop app or scripts).

## 2. High-Level Architecture
- API: Single HTTP service exposed as a Cloudflare Worker with CORS enabled for cross-origin access.
- Storage: 
  - Primary data in Cloudflare D1 (SQL) for documents.
  - Vector embeddings stored in Cloudflare Vectorize for similarity search.
- Embeddings: Generated via Cloudflare AI (model: BAAI bge-base-en v1.5) for both document content and queries.
- Client: A React web Single‑Page Application (SPA) that consumes the API and persists local configuration.

## 3. Entities and Data
- Document
  - id: Globally unique identifier (UUID).
  - title: Non-empty string.
  - content: Non-empty string containing the body to embed and store.
  - vector_id: Identifier used in the vector index (same as document id).
  - created: Unix epoch seconds when the document record was created.

## 4. API Surface
All endpoints are prefixed under `/api` and return JSON. CORS headers present on all responses. Non-allowed methods return 405.

- Health
  - Method/Path: GET `/api/health`
  - Response: `{ ok: true, timestamp, env, bindings: { DB, VECTORS, AI } }` for smoke tests and monitoring.

- Create Document
  - Method/Path: POST `/api/documents`
  - Request Body: `{ title: string, content: string }`
  - Processing:
    - Generate an embedding (via Cloudflare AI bge-base-en v1.5) for `content`.
    - Upsert vector into Vectorize with metadata including `title`.
    - Insert document row into D1 with `id`, `title`, `content`, `vector_id`, and `created` timestamp.
  - Response: `{ id, title, content }` on success; 500 on embedding/storage failures.

- Get Document
  - Method/Path: GET `/api/documents/{id}`
  - Response: Full document row on success; 404 if not found.

- List Documents
  - Method/Path: GET `/api/documents`
  - Behavior: Returns the most recent documents.
  - Response: `{ documents: Array<{ id, title, created }> }` sorted by `created` DESC; limited set (see Limits).

- Search Documents
  - Method/Path: GET `/api/search`
  - Query Params:
    - `q` (required): free-text query.
    - `limit` (optional): max number of results to return.
  - Processing:
    - Generate query embedding (same model as indexing).
    - Query Vectorize for nearest neighbors with metadata returned.
  - Response: `{ query, results: Array<{ id, title, similarity }> }`.
  - Errors: 400 on missing `q`; 500 on embedding or vector query failures.

## 5. Search Behavior
- Embedding Model: Cloudflare AI `@cf/baai/bge-base-en-v1.5` for both content and queries.
- Similarity: Nearest-neighbor search in Vectorize; results include similarity score.
- Metadata: Each vector stores the document `title` for result labeling; document content is not returned by search.

- ## 6. Client-Side Functional Configuration
- Local Configuration Keys (persisted per browser):
  - `openrouter_api_key`: API key string for third-party LLM provider.
  - `openrouter_model`: Identifier of the selected LLM model.
  - `llm_prompt`: System prompt string used by the client for LLM features.
- Model Discovery: Client fetches available models from OpenRouter’s public models endpoint.
- Note: These LLM configuration features are client-local; the described backend API does not consume these values.

## 7. Hosting and Deployment
- Platform: Cloudflare Workers (API service).
- Infrastructure Bindings (Wrangler):
  - D1 database bound as `DB` (database name "glassroot").
  - Vectorize index bound as `VECTORS` (index name "glassroot-vectors").
  - Cloudflare AI bound as `AI`.
- Environments:
  - Local Development: `wrangler dev` with local bindings; API served on a local port.
  - Production: Deployed via `wrangler deploy` to a Workers domain (e.g., `https://<worker>.<subdomain>.workers.dev`).
- Client API Base:
  - Development: points to local Worker dev URL.
  - Production: points to the deployed Workers endpoint.

## 8. Data Storage Requirements
- D1 (SQL):
  - Single table `documents` with columns `{ id TEXT PRIMARY KEY, title TEXT NOT NULL, content TEXT NOT NULL, vector_id TEXT, created INTEGER DEFAULT unixepoch() }`.
  - Indexing: Primary key on `id`. Additional indices not mandated by code but may be added for list queries.
- Vectorize:
  - Stores per-document embedding vectors keyed by `id`.
  - Metadata: Must include `title` for search result display.
- Consistency:
  - Document insert and vector upsert should target the same `id`.
  - On failures after partial success, system may leave orphaned entries; no automatic remediation is defined.

## 9. Errors and Status Codes
- 200: Successful operations returning JSON payloads.
- 400: Missing query parameter for search.
- 404: Document not found for `GET /api/documents/{id}`.
- 405: Method not allowed for unsupported HTTP methods on a route.
- 500: Internal errors (embedding, vector operations, database failures, or uncaught exceptions).

Standard error schema for all non-2xx responses:
- `{ error: string, status: number, timestamp: string, correlationId: string }` with `X-Correlation-Id` header set.

## 10. Limits and Defaults
- Document List: Returns up to 50 most recent entries.
- Search Results: Returns up to `min(limit, 20)` items; default `limit` is 10 if omitted.
- CORS: Enabled for all origins and standard headers/methods.
  - Production/Staging: Restrict to trusted origins per environment.
  - Rate limiting: Apply basic per-IP throttling to POST `/api/documents` (e.g., ~60 rpm) in production.

## 11. Operational Considerations
- Observability: Not defined; no logging or tracing contract required by current functionality.
- Rate Limiting: Not defined; recommended to add at the Worker level if needed.
- Backups/Migrations: D1 schema requires creation of `documents` table; migrations beyond initial schema are not defined.
- Error Messages: JSON errors include a generic message; no detailed diagnostics exposed to clients.

## 12. Security and Privacy
- CORS: Currently permissive (allows `*`). Consider restricting to trusted origins in production.
- Secrets: API does not accept user-provided secrets; Cloudflare account binds `DB`, `VECTORS`, and `AI`.
- Data Residency: Governed by Cloudflare D1/Vectorize regions (not specified here).
- PII: Document content may include arbitrary text; no redaction or classification performed.

## 13. Out of Scope / Non-Goals
- No document update or delete endpoints.
- No batching or pagination for list/search beyond fixed limits.
- No authentication/authorization.
- No file uploads; only plain text `content`.
- No multi-tenant isolation beyond per-account bindings.

## 14. Assumptions
- Cloudflare bindings (`DB`, `VECTORS`, `AI`) are configured and available at runtime.
- Vector dimension and model compatibility remain stable for stored vectors.
- Client handles any LLM interactions separately from the described API.

## 15. Future Extensions (Optional)
- Add update/delete document endpoints and cascade vector updates/deletes.
- Add pagination and total counts for list/search.
- Restrict CORS origins and add API authentication (e.g., JWT, service keys).
- Introduce background jobs for (re)embedding or model migrations.
 - Add observability (structured logs, metrics, traces) and error codes.

## 16. App Functional Requirements

- Site Menu: Provides navigation between two primary sections: Home and Documents.

- Home (LLM):
  - Runs an LLM session using the configured OpenRouter API key, selected model, and system prompt.
  - Applies the system prompt as the conversation’s instruction and routes model calls to the chosen engine.
  - If required configuration (API key and model) is missing, LLM features are disabled until configured.
  - No server-side persistence is required for conversations; behavior is client-driven.

- Documents:
  - Create: Allows creating a new document (title, content) and submits to the backend `POST /api/documents`.
  - Read: Opens an existing document by id via `GET /api/documents/{id}`.
  - List: Displays the most recent documents via `GET /api/documents`.
  - Search: Performs semantic search against the backend via `GET /api/search?q=...&limit=...` and shows result ids/titles with similarity score.
  - Update/Delete: Not available in the current backend; the UI should omit or disable these actions until API support is added.
  - Last updated: When showing cached lists, display "Last updated <time>"; refresh updates the timestamp.

- Configuration Panel:
  - Theme: Toggle between light and dark mode; selection persists across sessions and updates app theme immediately.
  - Model Prompt: Uses a CodeMirror-based editor with Markdown syntax highlighting; the editor auto-expands to accommodate prompt length.
  - LLM Engine Choice: Fetches the available models from the OpenRouter public models endpoint and lets the user select one; selection persists.
  - OpenRouter API Key: Captures and stores an API key in a password-type field with a visibility toggle (eye) to show/hide the value.
  - Persistence: Stores configuration locally via `localStorage` under stable keys.
  - Effect of Changes: Updated configuration takes effect for subsequent LLM requests on the Home section without requiring an app restart.
  - Prompt Editor: Markdown syntax highlighting with optional preview; code-split load where possible to reduce initial bundle size.

## 17. Offline and Error Fallbacks

- Global Offline Detection:
  - Detect lack of network connectivity and display an offline state indicator at the app level.
  - Prevent network actions while offline and surface clear, contextual messages; allow manual retry once connectivity is restored.

- Model List Retrieval (OpenRouter):
  - On fetch failure, fall back to the last successfully cached model list (if present) and label it as “stale”.
  - If no cache exists, display an error message and disable model selection until connectivity returns; preserve the currently selected model.

- Home (LLM):
  - Missing Configuration: If API key or model is unset, disable send/inference actions and show a configuration-required message.
  - Network/Provider Errors: Surface the original provider error message with status details; keep the user’s input intact for retry.
  - Timeouts/Unknown Errors: Present the original message where available and a plain-language summary; provide a retry affordance.

- Documents:
  - Create: On submission failure, retain the unsaved title/content locally as a draft and show the error; allow resubmission.
  - List: On failure, show the last successful list (if cached) marked as “stale”; otherwise present a no-connection error with retry.
  - Read: On failure, present the error; if a cached copy exists, show it with a “stale” indicator.
  - Search: On failure, present the error; no local semantic fallback is required.

- Backend Failures (Embeddings/Vector/DB):
  - Propagate the server’s error message payload to the client for display in context (creation/search/list/get).
  - Do not suppress or rewrite messages except to redact secrets; attach operation metadata (where available) to aid support.
  - Copy details: Provide a UI action to copy error details including status, timestamp, and correlationId (secrets redacted).

## 18. Error Surfacing Requirements

- Original Messages: Always surface the original error message text from both client-side exceptions and server responses in the relevant context (Home LLM, Documents create/list/search/read, Config fetching models).
- Contextual Placement: Display errors inline to the action area without requiring navigation; avoid modal-only reporting.
- Structure and Detail:
  - Include operation name, HTTP status (if applicable), and a short human-readable summary alongside the original message.
  - Include a timestamp and, when available, a request or correlation id returned by the server or platform.
- Redaction: Never display secrets or tokens in error messages; replace any detected secret substrings with a fixed mask.
- Persistence (Optional): Maintain a transient, in-session error log for diagnostics during development; clear log on restart.
- Developer Mode: In development builds, log full stack traces to the console; production builds limit details to user-safe content while preserving original message text.
- Retry Guidance: Provide a clear next step (retry, edit configuration, check connectivity) without automating retries that could amplify rate limits.
 - Queued Retry: Allow explicit user-triggered retry of the last failed action upon reconnect; avoid automatic background retries.

## 19. UX Design Requirements (LLM-Ingestible)

- Clarity and Hierarchy: Prioritize information density and scannability with clear visual hierarchy, consistent spacing, and legible typography.
- Responsiveness and Adaptivity: Layouts adapt gracefully from phone to desktop; controls remain reachable and readable across breakpoints.
- Performance: Interactive feedback appears within 100ms; visible progress indicators are shown for operations exceeding 300ms.
- Theming: Maintain first-class light/dark themes with coherent color systems and accessible contrast ratios; user theme persists.
- Accessibility: Support keyboard navigation, screen reader labels, and sufficient hit targets; avoid color-only signaling.
- State Feedback: Provide distinct, unobtrusive cues for loading, success, empty, and error states; avoid ambiguous intermediate states.
- Microinteractions: Use subtle motion and state transitions to reinforce causality; animations are brief, interruptible, and respect reduced-motion settings.
- Content Editing: The prompt editor supports Markdown with syntax highlighting and scales to long content without performance degradation.
- Empty and Stale States: Design helpful empty states that guide first actions; stale cached data is clearly marked and non-confusing.
- Progressive Disclosure: Expose advanced options without overwhelming first-time use; defaults are sensible and safe.
- Internationalization Readiness: All user-facing strings are externalizable; layouts accommodate longer strings without truncation.
- Safety and Trust: Prevent accidental data loss with draft preservation and confirmation where destructive actions may be introduced later; never expose secrets in UI.
