Architecture verdict: DRIFTING

Map Layers & Flow
- Domain: Documents (id, title, content, created), Embeddings (numeric vectors), Search results (id, title, similarity).
- Application: Request handling + validation in `api/src/index.ts` using Zod for create, limits for search; no separate service layer.
- Interface: HTTP API on Cloudflare Workers (`/api/health`, `/api/documents` CRUD subset, `/api/search`); React client (Vite) with router pages; chat UI powered by `@llamaindex/chat-ui` + custom OpenRouter hook.
- Infrastructure: Cloudflare D1 (`DB`), Vectorize (`VECTORS`), Workers AI (`AI`), Wrangler config; client deploy via Pages; Capacitor for mobile shells.
- Critical flows:
  - Document create → embed → vector upsert → DB insert → JSON response. Crossings: HTTP → Worker → AI → Vectorize → D1.
  - Search → embed query → vector query → map matches → JSON response. Crossings: HTTP → Worker → AI → Vectorize.
  - Chat (client-only) → OpenRouter fetch from browser using user-supplied API key; streaming SSE parsing; rendered by chat UI.

Boundary Violations
- Leaking infra detail: `GET /api/documents/:id` returns `vector_id` (infrastructure key) to the UI; page types include it though not used. file: `api/src/index.ts` (SELECT includes `vector_id`).
- Split LLM boundary: Client talks directly to OpenRouter (separate auth, telemetry, and error shape) while rest of app uses the Worker API. This bifurcates observability and error contracts across boundaries.
- Error contracts diverge: API error payload shape (`{ error, status, timestamp, correlationId }`) vs client-thrown network shape (Axios-like shim in `client/src/lib/api.ts`). Two incompatible error stories coexist.

Flow Leaks & Round-Trips
- Chat goes around the backend. Consequences: duplicated error handling, cross-origin risk, key storage in localStorage, and no server-side correlation IDs. Consider a thin proxy in the Worker to unify.
- Document flows are efficient (no N+1). Search clamps topK and avoids returning embeddings.

Surface Diet (delete/inline/rename)
- Do not expose `vector_id` to the client.
  - Before: API returns row with `vector_id`; client types depend on it in `DocumentViewPage.tsx`.
  - After: API hides `vector_id`; return only `{ id, title, content, created }`.
- Unused debug util: `client/src/utils/debug.ts` has a large ViewportDebugger with no references. Delete until a concrete use-case appears.
- Platform utility is oversized for usage.
  - Used now only for `isIOS | isAndroid | hasTouch` checks in `CustomChatInput`.
  - Trim or split to a focused `platform-lite.ts` consumed by chat input; keep the rest behind a separate import for pages that need it.
- Theme bootstrap duplication:
  - App sets theme on mount; `ThemeToggle` also toggles localStorage and DOM class. Prefer a single, minimal inline script in `index.html` to set `dark` before React mounts, then let `ThemeToggle` flip it.
- Error normalization duplicated in two places:
  - `client/src/lib/errors.ts` (pushError) and `client/src/components/ErrorBlock.tsx` (normalizeError) implement similar logic. Extract `normalizeError` to `client/src/lib/error-utils.ts` and consume in both.
- `client/src/lib/api.ts` invents an Axios-like error shape. Replace with a narrow `ApiError` type and a single throw shape.

Contracts & Temporal Semantics
- Input validation: Good use of Zod for create; search clamps input and enforces integer bounds. Keep all API inputs validated with Zod and return typed errors.
- Error payload: API includes timestamp ISO and correlation ID; keep as the canonical error contract and reflect it in client error types.
- Time units: `created` is treated as seconds on the client (`* 1000`). Ensure D1 returns seconds consistently; if not, normalize on the server to milliseconds or seconds explicitly and document it.

Symmetry & Naming
- Keep API JSON shapes minimal and symmetric across endpoints: list → `{ documents: Array<{ id, title, created }> }`; item → `{ id, title, content, created }`; search → `{ query, results: Array<{ id, title, similarity }> }`.
- Consistent error types: Single `ErrorPayload` with same keys on both client and server.
- Page layout is unified via `PageLayout` — good. Avoid path string checks in `App.tsx` for padding; let pages decide their own spacing via `PageLayout`.

Observability & Testability
- Good: Response headers include `X-Correlation-Id`; client `ErrorBlock` displays it. Consider adding a minimal `console.log(JSON.stringify({ path, method, status, correlationId }))` in the Worker (guarded for dev) or sending to Wrangler tail.
- Provide seams: `embedText` is pure given `env`; small and testable. Keep core pure and introduce small adapters at the edges.

Performance & Migrations
- Worker endpoints are O(1) and small. Vector query returns metadata only — correct.
- Client bundle includes `@llamaindex/chat-ui` (heavy). If bundle size matters, lazy-load chat screen.
- D1 schema handled via `schema.sql`; ensure forward-safe changes with new columns defaulted and additive migrations.

API Before → After (sketches)
- GET /api/documents/:id
  - Before: `{ id, title, content, vector_id, created }`
  - After: `{ id, title, content, created }`
- Client `DocRow` type updated accordingly; `vector_id` removed.

Minimal PR Plan (2–4 reversible commits)
1) Tighten API responses and types
   - Remove `vector_id` from SELECT/response; add response types in `api/src/index.ts`.
   - Add `created` normalization (seconds → ms) if needed; document in code.
2) Normalize client error handling
   - Add `client/src/lib/error-utils.ts` with `normalizeError` and `ErrorPayload`.
   - Refactor `ErrorBlock` and `pushError` to import and use it.
   - Simplify `client/src/lib/api.ts` to throw `ApiError` of the same shape.
3) Theme bootstrap + layout cleanup
   - Inline theme bootstrap in `client/index.html` to avoid FOUC; remove `useEffect` theme init in `App.tsx`.
   - Move route-specific paddings into each page via `PageLayout` instead of path checks in `App.tsx`.
4) Surface diet
   - Delete `client/src/utils/debug.ts` (unused).
   - Extract `client/src/utils/platform-lite.ts` exporting just `isIOS|isAndroid|hasTouch`; switch `CustomChatInput` to use it.
   - Optionally split full `platform.ts` into its own feature folder for future PWA/Capacitor screens.

Proposed Diffs (safe, local)
- API: Stop leaking vector_id
  - `api/src/index.ts` (document view): change SELECT to `id, title, content, created`; adjust `jsonResponse` payload accordingly.
- Client: Single error contract
  - Add `client/src/lib/error-utils.ts`:
    - `export type ErrorPayload = { message: string; status?: number; timestamp?: string; correlationId?: string }`
    - `export function normalizeError(e: unknown): ErrorPayload { /* consolidated logic */ }`
  - Update `client/src/lib/errors.ts` to import and reuse `normalizeError`.
  - Update `client/src/components/ErrorBlock.tsx` to import and reuse `normalizeError`.
  - Update `client/src/lib/api.ts` to throw `{ error: message, status, timestamp, correlationId }` directly.
- Client: Theme bootstrap
  - `client/index.html`: add inline script before bundle to set `documentElement.classList` from `localStorage.getItem('theme') ?? prefers-color-scheme`.
  - `client/src/App.tsx`: remove theme `useEffect` initializer; rely on `ThemeToggle` for interactions.
- Surface diet
  - Remove `client/src/utils/debug.ts`.
  - Add `client/src/utils/platform-lite.ts` exporting just `isIOS`, `isAndroid`, `hasTouch`; switch `CustomChatInput` import.

Notes on Risk
- Hiding `vector_id` reduces coupling; no UI currently uses it.
- Error normalization refactor is internal to the client and should not change UX; keep messages identical.
- Theme bootstrap script eliminates a render flash; no behavioral change.
- Deleting unused debug util is no-op for runtime.

Additional Observations (consistency)
- `client/src/lib/api.ts` default `API_BASE` reads `import.meta.env.VITE_API_BASE || ""`; ensure `.env` values in Pages and native builds align to avoid accidental same-origin assumptions.
- Consider centralizing outbound LLM calls behind the Worker to unify auth, rate limit, and error contracts. If kept on client, add a tiny `OpenRouterError` mapper to the same `normalizeError` to align messaging.
- Keep route handlers small; the current Worker file is compact. If it grows, split by feature but keep pure helpers in `utils.ts` and route glue at the edge.

Verdict Summary
- The core is clean but drifting: two error models, theme initialization in two places, infra detail leaking to UI, oversized platform utility. Trim surfaces, unify error/response contracts, and centralize theme bootstrap.

